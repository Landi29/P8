\subsection{SimRank}
And important algorithm for computing the similarity between graphs is SimRank\cite{10.1145/775047.775126}. The intuition behind the SimRank algorithm is is as the author states in the paper \emph{"two objects are similar if they are referenced by similar objects"}\cite{10.1145/775047.775126}. What the algorithm does is that it assigns a similarity score between 0 and 1 based on how similar two objects are. The basic SimRank equation can be seen below:
\begin{definition}[SimRank]\label{def:simrank} Given two objects $a$ and $b$ as input we compute the similarity $s(a,b) \in [0,1]$ via the following recursive equation:
	\begin{equation}
	s(a,b)= \frac{C}{|I(a)||I(b)|}\sum^{|I(a)|}_{i=1}\sum^{|I(b)|}_{j=1}s(I_i(a),I_j(b))
	\end{equation}
	Here C is the confidence level or decay factor which is a constant between 0 and 1. If $a=\emptyset$ and $b= \emptyset$ then $s(a,b) = 0$. If both $a$ and $b$ are not $\emptyset$ then we compute $s(a,b)$ by iterating over all in-neighbor pairs of $a$ and $b$ and sum up the similarity $s(I_i(a),I_j(b)$ of these pairs. The similarity is then divided by the total number of in-neighbor pairs in order to normalize it. That is, the similarity between a and b is the average similarity between in-neighbors of $a$ and in-neighbors of $b$. It is important to note here that the similarity between an object and itself is 1\cite{10.1145/775047.775126}.
\end{definition}

%\Jeg er lidt usikker på om det er nødvendigt at snakke om bipartite simRank så det kan godt være at alt dette ikke er nødvendigt
It is also possible to extend the above equation to bipartite domains consisting of two types of objects. The idea here is that we can compute similarity of two objects of one type based the objects they reference which are of another type. An example of this could be trying to figure out the similarity two customers based on the items they have bought\cite{10.1145/775047.775126}.The equations for computing the similarity of object in bipartite domains can be seen below:

\begin{definition}[Bipartite SimRank]\label{def:bipartite_simrank} Given two objects A and B of type 1 which reference objects of type 2 and objects c and of type 2 which gets referenced by objects of type 1 the similarity can be computed via the follow mutually-recursive equations:
	
	For objects of type 1 where $A \neq B$ the similarity is computed as:
	\begin{equation}
	s(A,B)= \frac{C_1}{|O(A)||O(B)|}\sum^{|O(A)|}_{i=1}\sum^{|O(B)|}_{j=1}s(O_i(A),O_j(B))
	\end{equation}
	
	For objects of type 2 where $c \neq d$ the similarity is computed as:
	\begin{equation}
	s(c,d)= \frac{C_2}{I|(c)||I(d)|}\sum^{|I(c)|}_{i=1}\sum^{|I(d)|}_{j=1}s(I_i(c),I_j(d))
	\end{equation}
	
	We can then compute the bipartite SimRank score by checking $C_1 = C_2$\cite{10.1145/775047.775126}.
\end{definition}

The way that SimRank is computed for a graph $G$ can be done via iterating to fixed-point. Let $n$ be the number of nodes within graph $G$, for each iteration $k$ we can keep $n^2$ entries $R_k(*,*)$ of length $n^2$, where $R_k(a,b)$ give the similarity score between $a$ and $b$ on iteration $k$\cite{10.1145/775047.775126}. We can compute $R_{k+1}(a,b)$ based on $R_k(a,b)$. First we have to compute $R_0(a,b)$ which is the lower bound of the similarity score $s(a,b)$:
\begin{equation}
R_0(a,b)= \begin{cases}
0, & (\text{if } a \neq b) \\

1 \quad (\text{if } a = b)
\end{cases}
\end{equation}

To compute compute $R_{k+1}(a,b)$ from $R_k(*,*)$ we use the equation below which is simply a modification of the basic SimRank equation mentioned earlier:
\begin{equation}
R_{k+1}(a,b)= \frac{C}{|I(a)||I(b)|}\sum^{|I(a)|}_{i=1}\sum^{|I(b)|}_{j=1}s(I_i(a),I_j(b))
\end{equation}

What the above equation states is that for $a \neq b$ and $R_{k+1}(a,b) = 1$ for $a = b$ we update for $(a,b)$ on each iteration $k+1$ using the similarity of the neighbors of $(a,b)$ from the previous iteration $k$. The values $R_k(*,*)$ are nondecreasing as $k$ increases. 
